# ESTRATEGIA TÉCNICA: SISTEMA DE AUDITORÍA Y ARQUITECTURA ASÍNCRONA (BULLMQ)
=====================================================================================

## 1. CONTEXTO Y VISIÓN
Este documento redefine la estrategia de implementación para el módulo de Auditoría y sienta las bases de la infraestructura asíncrona del proyecto (Backend Academia Pásalo). El objetivo es pasar de una ejecución sincrona a un sistema resiliente basado en colas de trabajo, preparado para escalar hacia notificaciones y procesos masivos.

## 2. ESTADO ACTUAL (HITOS COMPLETADOS)
- **Motor de Auditoría Híbrido:** Unificación de `audit_log` (Negocio) y `security_event` (Seguridad).
- **Endpoint de Historial:** `GET /audit/history` optimizado con paginación y caché de IDs.
- **Exportación Profesional:** `GET /audit/export` implementado con `exceljs`, soportando descargas de hasta 1000 registros con formato visual corporativo.
- **Calidad:** Tests E2E cubriendo autenticación, filtrado y generación binaria de Excel.

---

## 3. FASE CRÍTICA: INFRAESTRUCTURA DE COLAS (BACKGROUND JOBS)

### ¿Por qué BullMQ + Redis?
Para implementar la **Depuración Automática (Cleanup)** y futuras **Notificaciones**, rechazamos el uso de Cron Jobs simples en memoria (`@nestjs/schedule` aislado) por los siguientes riesgos:
1.  **Pérdida de Tareas:** Si el servidor reinicia durante la ejecución, el trabajo se pierde.
2.  **Bloqueo del Event Loop:** Borrar 1 millón de registros o enviar 5,000 correos bloquea la API principal.
3.  **Escalabilidad Nula:** No permite separar los "Workers" a otro servidor en el futuro.

**Solución:** Arquitectura Productor-Consumidor con BullMQ persistiendo en Redis.

### Plan de Arquitectura (Infraestructura Compartida)
Se creará un módulo transversal para que `Audit`, `Notifications` y futuros módulos consuman la misma conexión.

**Estructura de Carpetas:**
```
src/
├── infrastructure/
│   ├── queue/              <-- NUEVO MÓDULO CORE
│   │   ├── queue.module.ts (Configura BullModule.forRootAsync reutilizando variables de Redis)
│   │   └── queue.constants.ts (Definición de colas: 'audit-queue', 'notifications-queue')
```

### Configuración Global
El comportamiento del sistema será controlado dinámicamente por el Super Admin a través de la tabla `system_setting`.
- **Clave:** `AUDIT_CLEANUP_RETENTION_DAYS`
- **Valor:** Entero (ej. `30`, `60`, `365`).
- **Unidad:** Días (mayor precisión que meses).

---

## 4. HOJA DE RUTA (ROADMAP) DETALLADA

### PASO 1: INFRAESTRUCTURA BASE (COLAS)
- **Objetivo:** Habilitar el procesamiento en segundo plano.
- **Acciones:**
  1. Instalar dependencias: `npm install bullmq @nestjs/bullmq @nestjs/schedule`.
  2. Implementar `QueueModule` en `src/infrastructure/queue`.
  3. Configurar conexión asíncrona usando `ConfigService` (leyendo `REDIS_HOST`, `REDIS_PORT`).

### PASO 2: DEPURACIÓN AUTOMÁTICA (AUDIT CLEANUP)
- **Objetivo:** Sistema de auto-mantenimiento que no congele la base de datos.
- **Componentes:**
  1. **Scheduler (El Reloj):** Un servicio con `@Cron` que solo "dispara" el evento a la cola. No procesa nada.
  2. **Processor (El Obrero):** `AuditCleanupProcessor` en `src/modules/audit`.
     - Escucha el job `cleanup-old-logs`.
     - Lee `AUDIT_CLEANUP_RETENTION_DAYS`.
     - Ejecuta borrado por lotes (Batch Delete) de 5,000 en 5,000 registros para evitar bloqueos de tabla.
     - Inserta un log de auditoría al finalizar: "Limpieza completada. X registros eliminados".

### PASO 3: CONTROL DE VISIBILIDAD GRANULAR (RBAC) - [EN STAND-BY]
- **Objetivo:** Permitir que el Super Admin decida qué ven los Administradores.
- **Estrategia (Pendiente de implementación final):**
  1. **Configuración:** `AUDIT_ADMIN_VISIBILITY_CONFIG` en `system_setting` (JSON definiendo permisos por categoría: Seguridad, Contenido, Usuarios).
  2. **Integridad Histórica:** Agregar columna `performer_role_code` a las tablas de logs para saber qué rol tenía el usuario *en el momento* de la acción.
  3. **Filtros Dinámicos:** `AuditService` inyectará cláusulas `WHERE` basadas en la configuración activa.

---

## 5. LINEAMIENTOS PARA DESARROLLADORES
- **Reutilización:** Todo módulo que requiera colas debe importar `QueueModule`, no configurar BullMQ por su cuenta.
- **Resiliencia:** Los Processors deben manejar errores y reintentos (configurar `attempts: 3` en los Jobs).
- **Visibilidad:** Todo Job de fondo debe dejar un rastro en `audit_log` si realiza cambios destructivos (como borrar datos).
